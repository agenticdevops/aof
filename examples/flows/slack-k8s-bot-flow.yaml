# Slack K8s Bot AgentFlow
#
# An event-driven workflow that connects Slack events to the K8s assistant agent.
# Supports mentions, direct messages, and slash commands.
#
# Prerequisites:
# - Slack App configured (see docs/tutorials/slack-bot.md)
# - SLACK_BOT_TOKEN environment variable (xoxb-...)
# - SLACK_SIGNING_SECRET environment variable
# - LLM API key (ANTHROPIC_API_KEY, OPENAI_API_KEY, or GOOGLE_API_KEY)
#
# To run:
#   # Set environment variables
#   export SLACK_BOT_TOKEN=xoxb-xxxxx
#   export SLACK_SIGNING_SECRET=xxxxx
#   export GOOGLE_API_KEY=xxxxx
#
#   # Apply the agent first
#   aofctl apply -f examples/agents/slack-k8s-bot.yaml
#
#   # Start the server
#   aofctl serve --port 3000 --config examples/flows/slack-k8s-bot-flow.yaml
#
#   # Expose with ngrok for development
#   ngrok http 3000
#
#   # Configure Slack to send events to: https://xxxx.ngrok.io/webhook/slack

apiVersion: aof.dev/v1
kind: AgentFlow
metadata:
  name: slack-k8s-bot-flow
  labels:
    platform: slack
    purpose: operations

spec:
  # Listen for Slack events
  trigger:
    type: Slack
    config:
      events:
        - app_mention       # @bot-name mentions
        - message           # Direct messages
        - slash_command     # /k8s commands
      bot_token: ${SLACK_BOT_TOKEN}
      signing_secret: ${SLACK_SIGNING_SECRET}

  # Workflow nodes
  nodes:
    # 1. Parse incoming Slack message
    - id: parse-message
      type: Transform
      config:
        script: |
          # Extract text, user, channel from trigger event
          export MESSAGE_TEXT="${event.text}"
          export SLACK_USER="${event.user}"
          export SLACK_CHANNEL="${event.channel}"
          export SLACK_TIMESTAMP="${event.ts}"

    # 2. Process with K8s assistant agent
    - id: agent-process
      type: Agent
      config:
        agent: slack-k8s-bot
        input: ${MESSAGE_TEXT}
        context:
          slack_channel: ${SLACK_CHANNEL}
          slack_user: ${SLACK_USER}

    # 3. Check if command requires approval
    - id: check-approval
      type: Conditional
      config:
        condition: ${agent-process.output.requires_approval} == true

    # 4a. Request approval via Slack (if needed)
    - id: request-approval
      type: Slack
      config:
        channel: ${SLACK_CHANNEL}
        thread_ts: ${SLACK_TIMESTAMP}
        message: |
          :warning: **Approval Required**

          User: <@${SLACK_USER}>
          Command: `${agent-process.output.command}`

          React with :white_check_mark: to approve or :x: to deny
        wait_for_reaction: true
        timeout_seconds: 300

    # 4b. Send immediate response (no approval needed)
    - id: send-response
      type: Slack
      config:
        channel: ${SLACK_CHANNEL}
        thread_ts: ${SLACK_TIMESTAMP}
        message: ${agent-process.output.output}

    # 5. Execute approved command
    - id: execute-command
      type: Agent
      config:
        agent: slack-k8s-bot
        input: "Execute the approved command: ${agent-process.output.command}"
      conditions:
        - from: request-approval
          reaction: white_check_mark

    # 6. Send execution result
    - id: send-result
      type: Slack
      config:
        channel: ${SLACK_CHANNEL}
        thread_ts: ${SLACK_TIMESTAMP}
        message: |
          :white_check_mark: **Executed**

          ${execute-command.output.output}

  # Node connections (flow graph)
  connections:
    # Parse message first
    - from: trigger
      to: parse-message

    # Then process with agent
    - from: parse-message
      to: agent-process

    # Check if approval needed
    - from: agent-process
      to: check-approval

    # If approval needed, request it
    - from: check-approval
      to: request-approval
      when: requires_approval == true

    # If no approval needed, send response directly
    - from: check-approval
      to: send-response
      when: requires_approval == false

    # After approval, execute command
    - from: request-approval
      to: execute-command

    # Send execution result
    - from: execute-command
      to: send-result

  # Global flow configuration
  config:
    default_timeout_seconds: 60
    verbose: true
    retry:
      max_attempts: 2
      initial_delay: "1s"
      backoff_multiplier: 2.0
